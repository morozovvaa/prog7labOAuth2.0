# Отчет по лабораторной работе: Реализация OAuth 2.0 (Authorization Code Flow)

---

## 1. Цели Работы

1. Ознакомиться с ролями и концепциями протокола **OAuth 2.0**.
2. Реализовать и протестировать поток **Authorization Code Flow** с использованием Python и библиотеки `requests-oauthlib`.
3. Успешно получить **Access Token** и использовать его для доступа к защищённому ресурсу (GitHub API).

---

## 2. Теоретические Сведения

**OAuth 2.0** — это протокол делегирования доступа, который позволяет приложению (Клиенту) получать доступ к ресурсам пользователя (Resource Owner) без прямого ввода его логина и пароля.

**Ключевые роли:**
* **Resource Owner:** Пользователь, владеющий данными.
* **Client:** Приложение, запрашивающее доступ.
* **Authorization Server:** Проверяет пользователя и выдает токены.
* **Resource Server:** Хранит данные и принимает Access Token.

**Authorization Code Flow:** Самый безопасный поток, где Клиент получает временный **Код Авторизации** через браузер, а затем обменивает его на **Access Token** через **защищенное серверное соединение** (back-channel).

---

## 3. Ход Работы и Результаты

### 3.1. Подготовка и Настройка Приложения

1.  **Настройка среды:** Установлены Python и библиотеки `requests-oauthlib`. Учетные данные (`CLIENT_ID` и `CLIENT_SECRET`) установлены как переменные окружения.
2.  **Конфигурация URI:** Для обеспечения безопасности и соответствия стандарту OAuth 2.0 (MUST utilize HTTPS) был установлен следующий URI: `REDIRECT_URI = "https://localhost:8000/callback"`.

<img width="669" height="494" alt="image" src="https://github.com/user-attachments/assets/f23df679-51c3-4d82-bd66-8387dde1c8d6" />


### 3.2. Выполнение Authorization Code Flow

Процесс был запущен с помощью скрипта `oauth_client.py`.

| Этап | Вывод Консоли и Действие | Вывод и Комментарий |
| :--- | :--- | :--- |
| **Шаг 1: Запрос кода** | Скрипт генерирует уникальный URL авторизации, содержащий `client_id` и `state`. | URL: `https://github.com/login/oauth/authorize?response_type=code&client_id=...&redirect_uri=https%3A%2F%2Flocalhost%3A8000%2Fcallback...`|
| **Шаг 2: Согласие** | Пользователь переходит по URL и нажимает **"Authorize"** на странице согласия GitHub, делегируя права `read:user`. | **[Вставьте Скриншот 3: Окно согласия]** *(Скриншот страницы GitHub с запросом разрешений.)* |

**Скриншот процесса обмена и доступа:**
<img width="974" height="488" alt="image" src="https://github.com/user-attachments/assets/854b8d3b-8cd7-4da1-beaa-dd5704b8b3ff" />

<img width="1378" height="701" alt="image" src="https://github.com/user-attachments/assets/e40f744e-42ee-4981-94aa-3e44c462ae8e" />


---
## 4. Ответы на Контрольные Вопросы

### 1. Роли в протоколе OAuth 2.0
Основные роли:
* **Resource Owner** (Владелец Ресурса): Пользователь, который обладает данными и делегирует права доступа.
* **Client** (Клиент): Приложение, запрашивающее доступ к данным от имени пользователя.
* **Authorization Server** (Сервер Авторизации): Система, которая проверяет подлинность пользователя и выдает токены.
* **Resource Server** (Сервер Ресурсов): Сервер, который хранит данные и предоставляет их на основе валидного Access Token.

### 2. Что такое Authorization Code и зачем он нужен?
**Authorization Code** — это временный, одноразовый код, выдаваемый Сервером Авторизации. Он используется для **безопасного обмена** на **Access Token** через прямое серверное соединение (back-channel), что исключает возможность перехвата самого токена в незащищенном браузере (front-channel).

### 3. Почему параметр state важен в запросе на авторизацию?
Параметр **`state`** важен для **предотвращения CSRF-атак** (Cross-Site Request Forgery). Клиент генерирует уникальное случайное значение `state` и отправляет его в запросе. Сервер Авторизации возвращает это же значение. Клиент проверяет совпадение, гарантируя, что полученный ответ с кодом авторизации соответствует ожидаемому запросу, и не был подделан злоумышленником.

### 4. Чем отличается Authorization Code Flow от Client Credentials Flow?
| Поток | Цель | Участие Пользователя |
| :--- | :--- | :--- |
| **Authorization Code** | Делегирование доступа к **ресурсам пользователя**. | **Обязательно** (аутентификация и согласие). |
| **Client Credentials** | Доступ к **ресурсам самого Клиента** (сервис-в-сервис). | **Отсутствует**. |

### 5. В каких случаях используется refresh token и какова его роль?
**Refresh Token** используется, когда **Access Token истекает** (обычно через короткий промежуток времени). Его роль — позволить Клиенту получить новый **Access Token** без необходимости заставлять пользователя проходить полный цикл авторизации и повторно вводить свои учетные данные.

---
